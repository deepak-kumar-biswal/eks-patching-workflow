name: Production EKS Patching - Hub Deployment

on:
  push:
    branches: [ main ]
    paths: [ 'terraform/hub/**' ]
  pull_request:
    branches: [ main ]
    paths: [ 'terraform/hub/**' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - development
        - staging
        - production
      destroy:
        description: 'Destroy infrastructure'
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  contents: read
  pull-requests: write
  issues: write

env:
  TF_VERSION: 1.6.6
  AWS_REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
  ENVIRONMENT: ${{ github.event.inputs.environment || 'production' }}

jobs:
  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    outputs:
      tf-plan: ${{ steps.plan.outputs.stdout }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.HUB_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHub-Actions-EKS-Hub-Deploy

      - name: Terraform Format Check
        id: fmt
        working-directory: ./terraform/hub
        run: terraform fmt -check -diff -recursive
        continue-on-error: true

      - name: Terraform Init
        id: init
        working-directory: ./terraform/hub
        run: |
          terraform init -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Validate
        id: validate
        working-directory: ./terraform/hub
        run: terraform validate -no-color

      - name: Run TFSec Security Scan
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: ./terraform/hub
          soft_fail: true

      - name: Run Checkov Security Scan
        id: checkov
        uses: bridgecrewio/checkov-action@master
        with:
          directory: ./terraform/hub
          quiet: true
          soft_fail: true

      - name: Terraform Plan
        id: plan
        working-directory: ./terraform/hub
        env:
          TF_VAR_region: ${{ env.AWS_REGION }}
          TF_VAR_orchestrator_account_id: ${{ vars.HUB_ACCOUNT_ID }}
          TF_VAR_name_prefix: ${{ vars.NAME_PREFIX }}
          TF_VAR_bedrock_agent_id: ${{ secrets.BEDROCK_AGENT_ID }}
          TF_VAR_bedrock_agent_alias_id: ${{ secrets.BEDROCK_AGENT_ALIAS_ID }}
          TF_VAR_wave_rules: ${{ vars.WAVE_RULES_JSON }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
        run: |
          terraform plan -no-color -out=tfplan
          terraform show -no-color tfplan
        continue-on-error: true

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v3
        with:
          name: tfplan
          path: ./terraform/hub/tfplan

      - name: Comment PR
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        env:
          PLAN: "terraform\n${{ steps.plan.outputs.stdout }}"
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const output = `#### EKS Patching Hub Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
            #### EKS Patching Hub Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
            #### EKS Patching Hub Terraform Validation ü§ñ\`${{ steps.validate.outcome }}\`
            #### EKS Patching Hub Terraform Plan üìñ\`${{ steps.plan.outcome }}\`
            
            <details><summary>Show Plan</summary>
            
            \`\`\`\n
            ${process.env.PLAN}
            \`\`\`
            
            </details>
            
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  lambda-tests:
    name: Lambda Function Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.9, 3.11]
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov moto[all] boto3 botocore

      - name: Run Lambda Function Tests
        working-directory: ./terraform/hub/lambda
        run: |
          # Create test files for each Lambda function
          for func in *.py; do
            echo "Testing $func"
            python -c "
          import sys
          import json
          sys.path.append('.')
          
          # Basic syntax and import test
          try:
              import ${func%.py}
              print('‚úÖ $func - Import successful')
          except Exception as e:
              print('‚ùå $func - Import failed:', str(e))
              sys.exit(1)
          
          # Basic handler test
          try:
              handler = getattr(${func%.py}, 'handler', None)
              if handler:
                  print('‚úÖ $func - Handler function found')
              else:
                  print('‚ö†Ô∏è  $func - No handler function found')
          except Exception as e:
              print('‚ùå $func - Handler test failed:', str(e))
              sys.exit(1)
          "
          done

      - name: EKS-specific Lambda Validation
        working-directory: ./terraform/hub/lambda
        run: |
          # Test EKS-specific imports and logic
          python -c "
          import PreEKSCheck
          import UpdateEksAddons
          import KarpenterRefresh
          import PostEKSVerify
          import AnalyzeWithBedrock
          import SendApprovalRequest
          import ApprovalCallback
          print('‚úÖ All EKS Lambda functions imported successfully')
          "

      - name: Generate Coverage Report
        working-directory: ./terraform/hub/lambda
        run: |
          echo "Lambda function validation completed for Python ${{ matrix.python-version }}"

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [validate, lambda-tests]
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup AWS CLI
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.HUB_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHub-Actions-EKS-Integration-Test

      - name: EKS Cluster Connectivity Test
        run: |
          # Test basic AWS connectivity and permissions
          aws sts get-caller-identity
          
          # Test EKS cluster listing (if accessible)
          aws eks list-clusters --region ${{ env.AWS_REGION }} --output table || echo "No EKS clusters accessible or none exist"
          
          # Test Step Functions permissions
          aws stepfunctions list-state-machines --region ${{ env.AWS_REGION }} --max-items 5 || echo "No Step Functions permissions or none exist"

      - name: Validate EKS Prerequisites
        run: |
          echo "Validating EKS patching prerequisites..."
          
          # Check for required IAM permissions
          aws iam get-role --role-name EKS-Patching-Role 2>/dev/null || echo "EKS patching role may need to be created"
          
          # Check for S3 bucket access
          if [ ! -z "${{ vars.S3_BUCKET }}" ]; then
            aws s3 ls s3://${{ vars.S3_BUCKET }}/ --recursive --max-items 1 || echo "S3 bucket access validation needed"
          fi

  deploy:
    name: Deploy to ${{ github.event.inputs.environment || 'production' }}
    runs-on: ubuntu-latest
    needs: [validate, lambda-tests]
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') || 
      (github.event_name == 'workflow_dispatch')
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Terraform Plan
        uses: actions/download-artifact@v3
        with:
          name: tfplan
          path: ./terraform/hub/

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.HUB_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHub-Actions-EKS-Deploy

      - name: Terraform Init
        working-directory: ./terraform/hub
        run: terraform init -backend-config="region=${{ env.AWS_REGION }}"

      - name: Pre-deployment Health Check
        run: |
          echo "Running pre-deployment health checks..."
          
          # Check AWS connectivity
          aws sts get-caller-identity
          
          # Validate environment variables
          echo "Environment: ${{ env.ENVIRONMENT }}"
          echo "AWS Region: ${{ env.AWS_REGION }}"
          echo "Hub Account ID: ${{ vars.HUB_ACCOUNT_ID }}"
          
          # Check for existing infrastructure
          aws stepfunctions list-state-machines --region ${{ env.AWS_REGION }} --max-items 5

      - name: Terraform Apply
        if: ${{ github.event.inputs.destroy != 'true' }}
        working-directory: ./terraform/hub
        env:
          TF_VAR_region: ${{ env.AWS_REGION }}
          TF_VAR_orchestrator_account_id: ${{ vars.HUB_ACCOUNT_ID }}
          TF_VAR_name_prefix: ${{ vars.NAME_PREFIX }}
          TF_VAR_bedrock_agent_id: ${{ secrets.BEDROCK_AGENT_ID }}
          TF_VAR_bedrock_agent_alias_id: ${{ secrets.BEDROCK_AGENT_ALIAS_ID }}
          TF_VAR_wave_rules: ${{ vars.WAVE_RULES_JSON }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
        run: |
          echo "Deploying EKS Patching Hub to ${{ env.ENVIRONMENT }} environment..."
          terraform apply -auto-approve tfplan

      - name: Terraform Destroy
        if: ${{ github.event.inputs.destroy == 'true' }}
        working-directory: ./terraform/hub
        env:
          TF_VAR_region: ${{ env.AWS_REGION }}
          TF_VAR_orchestrator_account_id: ${{ vars.HUB_ACCOUNT_ID }}
          TF_VAR_name_prefix: ${{ vars.NAME_PREFIX }}
          TF_VAR_bedrock_agent_id: ${{ secrets.BEDROCK_AGENT_ID }}
          TF_VAR_bedrock_agent_alias_id: ${{ secrets.BEDROCK_AGENT_ALIAS_ID }}
          TF_VAR_wave_rules: ${{ vars.WAVE_RULES_JSON }}
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
        run: |
          echo "Destroying EKS Patching Hub in ${{ env.ENVIRONMENT }} environment..."
          terraform destroy -auto-approve

      - name: Post-deployment Verification
        if: ${{ github.event.inputs.destroy != 'true' }}
        run: |
          echo "Running post-deployment verification..."
          
          # Check deployed Lambda functions
          aws lambda list-functions --region ${{ env.AWS_REGION }} | grep -i eks-patching || echo "No EKS patching Lambda functions found"
          
          # Check Step Functions state machines
          aws stepfunctions list-state-machines --region ${{ env.AWS_REGION }} | grep -i eks-patching || echo "No EKS patching state machines found"
          
          # Validate IAM roles
          aws iam list-roles | grep -i eks-patching || echo "EKS patching roles validation needed"

      - name: Generate Deployment Summary
        run: |
          echo "## EKS Patching Hub Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AWS Region**: ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Terraform Version**: ${{ env.TF_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Time**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered By**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Action**: ${{ github.event.inputs.destroy == 'true' && 'Destroy' || 'Deploy' }}" >> $GITHUB_STEP_SUMMARY

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: [deploy]
    if: success() && github.event.inputs.destroy != 'true'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Run OWASP Dependency Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'EKS-Patching-Hub'
          path: '.'
          format: 'ALL'

      - name: Security Scan Summary
        run: |
          echo "## Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Security scan completed for EKS Patching Hub deployment." >> $GITHUB_STEP_SUMMARY
          echo "Review the generated reports for any security findings." >> $GITHUB_STEP_SUMMARY

  cleanup:
    name: Cleanup Artifacts
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    steps:
      - name: Cleanup
        run: |
          echo "Cleaning up deployment artifacts..."
          echo "Deployment workflow completed."
